## 前言

快速排序又是一种分而治之思想在排序算法上的典型应用。

- 时间复杂度：O(NlogN)
- 空间复杂度：O(N)
- 稳定性：稳定

排序动画图：


![堆排序动态图](https://github.com/coderbruis/AlgorithmsInJava/blob/master/notes/pictures/quickSort.gif)

## 正文

### 1. 普通版快速排序

此版本快速排序没有考虑特殊情况，为最简易版本。

参考代码如下：
```
/**
 *
 * 快速排序
 *
 * @author LuoHaiYang
 */
public class QuickSort {

    /**
     * 对arr[left...right]部分进行partition操作
     * 返回p, 使得arr[left...p-1] < arr[p] ; arr[p+1...right] > arr[p]
     *
     * @param arr
     * @param left
     * @param right
     * @return
     */
    private static int partition(int[] arr, int left, int right) {

        int p = arr[left];

        // arr[left+1...j] < p;  arr[j+1...i) > p
        int j = left;
        for (int i = left + 1; i <= right; i++) {
            if (arr[i] < p) {
                j++;
                swap(arr, j, i);
            }
        }
        swap(arr, left, j);
        return j;
    }

    private static void sort(int[] arr, int left, int right) {
        if (left >= right) {
            return;
        }
        int p = partition(arr, left, right);
        sort(arr, left, p-1);
        sort(arr, p+1, right);
    }

    public static void sort(int[] arr) {
        int n = arr.length;
        sort(arr, 0, n-1);
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

### 2. 快速排序算法的优化

快速排序的最坏运行情况是 O(N^2)，比如说顺序数列的快排。但它的平摊期望时间是 O(NlogN)，且 O(NlogN) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

此处有两点可以进行优化。

1. 对于数组数小于15时，使用插入排序; 数据量较小时，插入排序效率跟高；
2. 对于快速排序的基准值，取随机数，防止数组退化为顺序数组，即快速排序平均时间复杂度退化为O(N^2)

参考代码如下：
```
/**
 * 快速排序的优化
 *
 * 对于近乎有序的数组，快速排序会退化为O(N^2)。
 *
 * @author LuoHaiYang
 */
public class QuickSort2 {

    /**
     * 对arr[left...right]部分进行partition操作
     * 返回p, 使得arr[left...p-1] < arr[p] ; arr[p+1...right] > arr[p]
     *
     * @param arr
     * @param left
     * @param right
     * @return
     */
    private static int partition(int[] arr, int left, int right) {

        //int p = arr[left];
        // ===================================== 优化2 =====================================
        // 避免快排退化为O(N^2)
        swap(arr, left, (int)Math.random()*(right - left + 1) + left);

        int p = arr[left];

        // arr[left+1...j] < p;  arr[j+1...i) > p
        int j = left;
        for (int i = left + 1; i <= right; i++) {
            if (arr[i] < p) {
                j++;
                swap(arr, j, i);
            }
        }
        swap(arr, left, j);
        return j;
    }

    private static void sort(int[] arr, int left, int right) {
        // ===================================== 优化1 =====================================
        // 如果左右数值小于15，则通过插入排序来进行排序
        if (right - left <= 15) {
            InsertionSort.sort(arr);
            return;
        }

        int p = partition(arr, left, right);
        sort(arr, left, p-1);
        sort(arr, p+1, right);
    }

    public static void sort(int[] arr) {
        int n = arr.length;
        sort(arr, 0, n-1);
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

### 3. 双路快排



## 参考